{"ast":null,"code":"import _regeneratorRuntime from \"/home/hadooop/Desktop/development/reactjs_project/React_Dynamic_Routes/React_Dynamic_Routes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/hadooop/Desktop/development/reactjs_project/React_Dynamic_Routes/React_Dynamic_Routes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/home/hadooop/Desktop/development/reactjs_project/React_Dynamic_Routes/React_Dynamic_Routes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { transformToNestObject, appendErrors } from 'react-hook-form';\n\nvar parseErrorSchema = function parseErrorSchema(error, validateAllFieldCriteria) {\n  return Array.isArray(error.inner) && error.inner.length ? error.inner.reduce(function (previous, _ref) {\n    var path = _ref.path,\n        message = _ref.message,\n        type = _ref.type;\n    var previousTypes = previous[path] && previous[path].types || {};\n    return Object.assign(Object.assign({}, previous), path ? {\n      [path]: Object.assign(Object.assign({}, previous[path] || {\n        message,\n        type\n      }), validateAllFieldCriteria ? {\n        types: Object.assign(Object.assign({}, previousTypes), {\n          [type]: previousTypes[type] ? [].concat(_toConsumableArray([].concat(previousTypes[type])), [message]) : message\n        })\n      } : {})\n    } : {});\n  }, {}) : {\n    [error.path]: {\n      message: error.message,\n      type: error.type\n    }\n  };\n};\n\nvar yupResolver = function yupResolver(schema) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    abortEarly: false\n  };\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(values, context) {\n      var validateAllFieldCriteria,\n          parsedErrors,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              validateAllFieldCriteria = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n              _context.prev = 1;\n\n              if (options.context && process.env.NODE_ENV === 'development') {\n                // eslint-disable-next-line no-console\n                console.warn(\"You should not used the yup options context. Please, use the 'useForm' context object instead\");\n              }\n\n              _context.next = 5;\n              return schema.validate(values, Object.assign(Object.assign({}, options), {\n                context\n              }));\n\n            case 5:\n              _context.t0 = _context.sent;\n              _context.t1 = {};\n              return _context.abrupt(\"return\", {\n                values: _context.t0,\n                errors: _context.t1\n              });\n\n            case 10:\n              _context.prev = 10;\n              _context.t2 = _context[\"catch\"](1);\n              parsedErrors = parseErrorSchema(_context.t2, validateAllFieldCriteria);\n              return _context.abrupt(\"return\", {\n                values: {},\n                errors: validateAllFieldCriteria ? parsedErrors : transformToNestObject(parsedErrors)\n              });\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 10]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n};\n\nvar convertArrayToPathName = function convertArrayToPathName(paths) {\n  return paths.reduce(function (previous, path, index) {\n    return \"\".concat(previous).concat(typeof path === 'string' ? \"\".concat(index > 0 ? '.' : '').concat(path) : \"[\".concat(path, \"]\"));\n  }, '').toString();\n};\n\nvar parseErrorSchema$1 = function parseErrorSchema$1(error, validateAllFieldCriteria) {\n  return Array.isArray(error.failures) ? error.failures.reduce(function (previous, _ref3) {\n    var path = _ref3.path,\n        _ref3$message = _ref3.message,\n        message = _ref3$message === void 0 ? '' : _ref3$message,\n        type = _ref3.type;\n    var currentPath = convertArrayToPathName(path);\n    return Object.assign(Object.assign({}, previous), path ? previous[currentPath] && validateAllFieldCriteria ? {\n      [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type || '', message)\n    } : {\n      [currentPath]: previous[currentPath] || Object.assign({\n        message,\n        type\n      }, validateAllFieldCriteria ? {\n        types: {\n          [type || '']: message || true\n        }\n      } : {})\n    } : {});\n  }, {}) : [];\n};\n\nvar superstructResolver = function superstructResolver(schema) {\n  return /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(values, _) {\n      var validateAllFieldCriteria,\n          _args2 = arguments;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              validateAllFieldCriteria = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;\n              _context2.prev = 1;\n              return _context2.abrupt(\"return\", {\n                values: schema(values),\n                errors: {}\n              });\n\n            case 5:\n              _context2.prev = 5;\n              _context2.t0 = _context2[\"catch\"](1);\n              return _context2.abrupt(\"return\", {\n                values: {},\n                errors: transformToNestObject(parseErrorSchema$1(_context2.t0, validateAllFieldCriteria))\n              });\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[1, 5]]);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n};\n\nvar parseErrorSchema$2 = function parseErrorSchema$2(error, validateAllFieldCriteria) {\n  return Array.isArray(error.details) ? error.details.reduce(function (previous, _ref5) {\n    var path = _ref5.path,\n        _ref5$message = _ref5.message,\n        message = _ref5$message === void 0 ? '' : _ref5$message,\n        type = _ref5.type;\n    var currentPath = convertArrayToPathName(path);\n    return Object.assign(Object.assign({}, previous), path ? previous[currentPath] && validateAllFieldCriteria ? {\n      [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type, message)\n    } : {\n      [currentPath]: previous[currentPath] || Object.assign({\n        message,\n        type\n      }, validateAllFieldCriteria ? {\n        types: {\n          [type]: message || true\n        }\n      } : {})\n    } : {});\n  }, {}) : [];\n};\n\nvar joiResolver = function joiResolver(schema) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    abortEarly: false\n  };\n  return /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(values, _) {\n      var validateAllFieldCriteria,\n          _args3 = arguments;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              validateAllFieldCriteria = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;\n              _context3.prev = 1;\n              _context3.next = 4;\n              return schema.validateAsync(values, Object.assign({}, options));\n\n            case 4:\n              _context3.t0 = _context3.sent;\n              _context3.t1 = {};\n              return _context3.abrupt(\"return\", {\n                values: _context3.t0,\n                errors: _context3.t1\n              });\n\n            case 9:\n              _context3.prev = 9;\n              _context3.t2 = _context3[\"catch\"](1);\n              return _context3.abrupt(\"return\", {\n                values: {},\n                errors: transformToNestObject(parseErrorSchema$2(_context3.t2, validateAllFieldCriteria))\n              });\n\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[1, 9]]);\n    }));\n\n    return function (_x5, _x6) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n};\n\nexport { joiResolver, superstructResolver, yupResolver };","map":{"version":3,"sources":["../src/yup.ts","../src/utils/convertArrayToPathName.ts","../src/superstruct.ts","../src/joi.ts"],"names":["parseErrorSchema"],"mappings":"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","sourcesContent":["import { Resolver, transformToNestObject } from 'react-hook-form';\nimport Yup from 'yup';\n\nconst parseErrorSchema = (\n  error: Yup.ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.inner) && error.inner.length\n    ? error.inner.reduce(\n        (previous: Record<string, any>, { path, message, type }) => {\n          const previousTypes = (previous[path] && previous[path].types) || {};\n          return {\n            ...previous,\n            ...(path\n              ? {\n                  [path]: {\n                    ...(previous[path] || {\n                      message,\n                      type,\n                    }),\n                    ...(validateAllFieldCriteria\n                      ? {\n                          types: {\n                            ...previousTypes,\n                            [type]: previousTypes[type]\n                              ? [...[].concat(previousTypes[type]), message]\n                              : message,\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n          };\n        },\n        {},\n      )\n    : {\n        [error.path]: { message: error.message, type: error.type },\n      };\n\nexport const yupResolver = <TFieldValues extends Record<string, any>>(\n  schema: Yup.ObjectSchema | Yup.Lazy,\n  options: Omit<Yup.ValidateOptions, 'context'> = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  context,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    if (\n      (options as Yup.ValidateOptions).context &&\n      process.env.NODE_ENV === 'development'\n    ) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"You should not used the yup options context. Please, use the 'useForm' context object instead\",\n      );\n    }\n    return {\n      values: (await schema.validate(values, {\n        ...options,\n        context,\n      })) as any,\n      errors: {},\n    };\n  } catch (e) {\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: validateAllFieldCriteria\n        ? parsedErrors\n        : transformToNestObject(parsedErrors),\n    };\n  }\n};\n","export default (paths: (string | number)[]): string =>\n  paths\n    .reduce(\n      (previous, path: string | number, index): string =>\n        `${previous}${\n          typeof path === 'string'\n            ? `${index > 0 ? '.' : ''}${path}`\n            : `[${path}]`\n        }`,\n      '',\n    )\n    .toString();\n","import { appendErrors, transformToNestObject, Resolver } from 'react-hook-form';\nimport Superstruct from 'superstruct';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: Superstruct.StructError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.failures)\n    ? error.failures.reduce(\n        (previous: Record<string, any>, { path, message = '', type }) => {\n          const currentPath = convertArrayToPathName(path);\n\n          return {\n            ...previous,\n            ...(path\n              ? previous[currentPath] && validateAllFieldCriteria\n                ? {\n                    [currentPath]: appendErrors(\n                      currentPath,\n                      validateAllFieldCriteria,\n                      previous,\n                      type || '',\n                      message,\n                    ),\n                  }\n                : {\n                    [currentPath]: previous[currentPath] || {\n                      message,\n                      type,\n                      ...(validateAllFieldCriteria\n                        ? {\n                            types: { [type || '']: message || true },\n                          }\n                        : {}),\n                    },\n                  }\n              : {}),\n          };\n        },\n        {},\n      )\n    : [];\n\nexport const superstructResolver = <TFieldValues extends Record<string, any>>(\n  schema: Superstruct.Struct,\n): Resolver<TFieldValues> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    return {\n      values: schema(values),\n      errors: {},\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(e, validateAllFieldCriteria),\n      ),\n    };\n  }\n};\n","import { appendErrors, transformToNestObject, Resolver } from 'react-hook-form';\nimport Joi from '@hapi/joi';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: Joi.ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.details)\n    ? error.details.reduce(\n        (previous: Record<string, any>, { path, message = '', type }) => {\n          const currentPath = convertArrayToPathName(path);\n\n          return {\n            ...previous,\n            ...(path\n              ? previous[currentPath] && validateAllFieldCriteria\n                ? {\n                    [currentPath]: appendErrors(\n                      currentPath,\n                      validateAllFieldCriteria,\n                      previous,\n                      type,\n                      message,\n                    ),\n                  }\n                : {\n                    [currentPath]: previous[currentPath] || {\n                      message,\n                      type,\n                      ...(validateAllFieldCriteria\n                        ? {\n                            types: { [type]: message || true },\n                          }\n                        : {}),\n                    },\n                  }\n              : {}),\n          };\n        },\n        {},\n      )\n    : [];\n\nexport const joiResolver = <TFieldValues extends Record<string, any>>(\n  schema: Joi.Schema,\n  options: Joi.AsyncValidationOptions = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    return {\n      values: await schema.validateAsync(values, {\n        ...options,\n      }),\n      errors: {},\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(e, validateAllFieldCriteria),\n      ),\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}